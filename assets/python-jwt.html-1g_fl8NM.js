const t=JSON.parse('{"key":"v-09324949","path":"/python/python-jwt.html","title":"Python中使用JWT","lang":"zh-CN","frontmatter":{"title":"Python中使用JWT","date":"2020-12-21T03:18:59.000Z","category":["技术","python"],"tag":["python","jwt","authorization"],"description":"在前后端分离的web项目中，后端一般采用Restful Api，这种模式的后端是无状态的， 不便再使用Session这种传统的认证方式，一般采用JWT。 基于jwt的鉴权机制也是无状态的，因此不需要在服务端去保留用户的认证信息或者会话信息，jwt是存储在客户端的，服务器端不需要存储jwt的，客户端每次发送请求时会携带该token，然后到服务器端会验证token是否正确，是否过期了，来验证token的有效性。 再Django中，使用restframework便可以很方便的使用jwt进行认证了，我们也可以通过标准库jwt来简单实现jwt加解密过程。","head":[["meta",{"property":"og:url","content":"https://arc.cpolar.cn/python/python-jwt.html"}],["meta",{"property":"og:site_name","content":"Maverick"}],["meta",{"property":"og:title","content":"Python中使用JWT"}],["meta",{"property":"og:description","content":"在前后端分离的web项目中，后端一般采用Restful Api，这种模式的后端是无状态的， 不便再使用Session这种传统的认证方式，一般采用JWT。 基于jwt的鉴权机制也是无状态的，因此不需要在服务端去保留用户的认证信息或者会话信息，jwt是存储在客户端的，服务器端不需要存储jwt的，客户端每次发送请求时会携带该token，然后到服务器端会验证token是否正确，是否过期了，来验证token的有效性。 再Django中，使用restframework便可以很方便的使用jwt进行认证了，我们也可以通过标准库jwt来简单实现jwt加解密过程。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-02T11:07:09.000Z"}],["meta",{"property":"article:author","content":"Chuanchao.peng"}],["meta",{"property":"article:tag","content":"python"}],["meta",{"property":"article:tag","content":"jwt"}],["meta",{"property":"article:tag","content":"authorization"}],["meta",{"property":"article:published_time","content":"2020-12-21T03:18:59.000Z"}],["meta",{"property":"article:modified_time","content":"2024-01-02T11:07:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Python中使用JWT\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-12-21T03:18:59.000Z\\",\\"dateModified\\":\\"2024-01-02T11:07:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Chuanchao.peng\\",\\"url\\":\\"https://github.com/PengchuanC\\"}]}"]]},"headers":[{"level":2,"title":"1.JWT加密","slug":"_1-jwt加密","link":"#_1-jwt加密","children":[]},{"level":2,"title":"2.JWT解密","slug":"_2-jwt解密","link":"#_2-jwt解密","children":[{"level":3,"title":"3.使用itsdangerous包","slug":"_3-使用itsdangerous包","link":"#_3-使用itsdangerous包","children":[]}]},{"level":2,"title":"4.在项目中使用","slug":"_4-在项目中使用","link":"#_4-在项目中使用","children":[]}],"git":{"createdTime":1704193629000,"updatedTime":1704193629000,"contributors":[{"name":"PengchuanC","email":"gameboynes@gmail.com","commits":1}]},"readingTime":{"minutes":1.76,"words":529},"filePathRelative":"python/python-jwt.md","localizedDate":"2020年12月21日","excerpt":"<p>在前后端分离的web项目中，后端一般采用Restful Api，这种模式的后端是无状态的，</p>\\n<p>不便再使用Session这种传统的认证方式，一般采用<strong>JWT</strong>。</p>\\n<p>基于jwt的鉴权机制也是无状态的，因此不需要在服务端去保留用户的认证信息或者会话信息，jwt是存储在客户端的，服务器端不需要存储jwt的，客户端每次发送请求时会携带该token，然后到服务器端会验证token是否正确，是否过期了，来验证token的有效性。</p>\\n<p>再Django中，使用restframework便可以很方便的使用jwt进行认证了，我们也可以通过标准库<code>jwt</code>来简单实现jwt加解密过程。</p>","autoDesc":true}');export{t as data};
